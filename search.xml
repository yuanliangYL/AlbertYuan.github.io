<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    
    
    
    
    <entry>
      <title>iOS多次移除Observer或者移除不存在的Observer导致崩溃的3中解决方案</title>
      <link href="/2021/08/05/iOSObserverCrashHandle/"/>
      <url>/2021/08/05/iOSObserverCrashHandle/</url>
      
        <content type="html"><![CDATA[<h4 id="问题引述：使用Observer时遇到Cannot-remove-an-observer-XXXXXXXX-for-the-key-path-“aObserverName”-from-XXXXXXXX-because-it-is-not-registered-as-an-observer"><a href="#问题引述：使用Observer时遇到Cannot-remove-an-observer-XXXXXXXX-for-the-key-path-“aObserverName”-from-XXXXXXXX-because-it-is-not-registered-as-an-observer" class="headerlink" title="问题引述：使用Observer时遇到Cannot remove an observer XXXXXXXX for the key path “aObserverName” from XXXXXXXX because it is not registered as an observer"></a>问题引述：使用Observer时遇到Cannot remove an observer XXXXXXXX for the key path “aObserverName” from XXXXXXXX because it is not registered as an observer</h4><h5 id="方案一：：利用-try-catch（只能针对删除多次KVO的情况下）"><a href="#方案一：：利用-try-catch（只能针对删除多次KVO的情况下）" class="headerlink" title="方案一：：利用 @try @catch（只能针对删除多次KVO的情况下）"></a>方案一：：利用 @try @catch（只能针对删除多次KVO的情况下）</h5><blockquote><p>利用 @try @catc:这种方法真是很Low,人就会有问题，不过很简单就可以实现。(对于初学者来说，如果不怕麻烦，确实可以使用这种方法)。这种方法只能针对多次删除KVO的处理，原理就是try catch可以捕获异常，不让程序catch。这样就实现了防止多次删除KVO。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;</span><br><span class="line">  [appDelegate removeObserver:self forKeyPath:@&quot;kvoState&quot;];</span><br><span class="line">&#125;</span><br><span class="line">@catch (NSException *exception) &#123;</span><br><span class="line">  NSLog(@&quot;多次删除kvo 报错了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法功能拓展：</p><p>有个简单的方法：给NSObject 增加一个分类，然后利用Runtime 交换系统的 removeObserver方法，在里面添加 @try @catch。</p></blockquote><hr><h5 id="方案二：：利用-模型数组-进行存储记录"><a href="#方案二：：利用-模型数组-进行存储记录" class="headerlink" title="方案二：：利用 模型数组 进行存储记录"></a>方案二：：利用 模型数组 进行存储记录</h5><ul><li>第一步 利用交换方法，拦截到需要的东西</li></ul><ol><li>是在监听哪个对象。</li><li>是在监听的keyPath是什么。</li></ol><ul><li>第二步 存储思路</li></ul><ol><li>我们需要一个模型用来存储哪个对象执行了addObserver、监听的KeyPath是什么。</li><li>我们需要一个数组来存储这个模型。</li></ol><ul><li>第三步 进行存储</li></ul><ol><li>利用runtime 拦截到对象和keyPath,创建模型然后进行赋值模型相应的属性。</li><li>然后存储进数组中去。</li></ol><ul><li>存储之前的检索处理</li></ul><ol><li>在存储之前，为了防止多次addObserver相同的属性，这个时候我们就可以，遍历数组，取出每个一个模型，然后取出模型中的对象，首先判断对象是否一致，然后判断keypath是否一致</li><li>对于添加KVO监听：如果不一致那么就执行利用交换后方法执行addObserver方法。</li><li>对于删除KVO监听: 如果一致那么我们就执行删除监听,否则不执行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">+ (void)switchMethod</span><br><span class="line">&#123;</span><br><span class="line">    SEL removeSel = @selector(removeObserver:forKeyPath:);</span><br><span class="line">    SEL myRemoveSel = @selector(removeDasen:forKeyPath:);</span><br><span class="line">    Method systemRemoveMethod = class_getClassMethod([self class],removeSel);</span><br><span class="line">    Method DasenRemoveMethod = class_getClassMethod([self class], myRemoveSel);</span><br><span class="line">    method_exchangeImplementations(systemRemoveMethod, DasenRemoveMethod);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SEL addSel = @selector(addObserver:forKeyPath:options:context:);</span><br><span class="line">    SEL myaddSel = @selector(addDasen:forKeyPath:options:context:);</span><br><span class="line">    Method systemAddMethod = class_getClassMethod([self class],addSel);</span><br><span class="line">    Method DasenAddMethod = class_getClassMethod([self class], myaddSel);</span><br><span class="line">    method_exchangeImplementations(systemAddMethod, DasenAddMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 第二种方案，利用私有属性</span><br><span class="line">// 交换后的方法</span><br><span class="line">- (void)removeDasen:(NSObject *)observer forKeyPath:(NSString *)keyPath&#123;</span><br><span class="line"></span><br><span class="line">    NSMutableArray *Observers = [YLObserver sharedInstanceObserve];</span><br><span class="line">    YLObserverData *userPathData = [self observerKeyPath:keyPath];</span><br><span class="line">    // 如果有该key值那么进行删除 ，对于删除KVO监听: 如果一致那么我们就执行删除监听,否则不执行</span><br><span class="line">    if (userPathData) &#123;</span><br><span class="line">        [Observers removeObject:userPathData];</span><br><span class="line">        @try &#123;</span><br><span class="line">            //如果没有写@try @catch 的话，在 dealloc 中，那个被监听的对象（appdelegate）必须要全局变量</span><br><span class="line">            [self removeDasen:observer forKeyPath:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">        @catch (NSException *exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 交换后的方法</span><br><span class="line">/*</span><br><span class="line"> 第一步 利用交换方法，拦截到需要的东西</span><br><span class="line"> 1，是在监听哪个对象。</span><br><span class="line"> 2，是在监听的keyPath是什么。</span><br><span class="line"> */</span><br><span class="line">- (void)addDasen:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     第二步 存储思路</span><br><span class="line">     1，我们需要一个模型用来存储哪个对象执行了addObserver、监听的KeyPath是什么。</span><br><span class="line">     2，我们需要一个数组来存储这个模型。</span><br><span class="line">     */</span><br><span class="line">    YLObserverData *userPathData= [[YLObserverData alloc]initWithObjc:self key:keyPath];</span><br><span class="line">    NSMutableArray *Observers = [YLObserver sharedInstanceObserve];</span><br><span class="line"></span><br><span class="line">    // 如果没有注册，那么才进行注册 第三步 存储之前的检索处理</span><br><span class="line">    if (![self observerKeyPath:keyPath]) &#123;</span><br><span class="line">        /*</span><br><span class="line">         第三步 进行存储</span><br><span class="line">         1，利用runtime 拦截到对象和keyPath,创建模型然后进行赋值模型相应的属性。</span><br><span class="line">         2，然后存储进数组中去。</span><br><span class="line">         */</span><br><span class="line">        [Observers addObject:userPathData];</span><br><span class="line">        [self addDasen:observer forKeyPath:keyPath options:options context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 进行检索，判断是否已经存储了该Key值</span><br><span class="line">- (YLObserverData *)observerKeyPath:(NSString *)keyPath&#123;</span><br><span class="line"></span><br><span class="line">    NSMutableArray *Observers = [YLObserver sharedInstanceObserve];</span><br><span class="line">    for (YLObserverData *data in Observers) &#123;</span><br><span class="line">        if ([data.objc isEqual:self] &amp;&amp; [data.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="方案三-利用-observationInfo-里私有属性"><a href="#方案三-利用-observationInfo-里私有属性" class="headerlink" title="方案三:利用 observationInfo 里私有属性"></a>方案三:利用 observationInfo 里私有属性</h5><ul><li>第一步 简单介绍下observationInfo属性</li></ul><ol><li>只要是继承与NSObject的对象都有observationInfo属性.</li><li>observationInfo是系统通过分类给NSObject增加的属性。</li><li>分类文件是NSKeyValueObserving.h这个文件</li><li>这个属性中存储有属性的监听者，通知者，还有监听的keyPath，等等KVO相关的属性。</li><li>observationInfo是一个void指针，指向一个包含所有观察者的一个标识信息对象，信息包含了每个监听的观察者,注册时设定的选项等。</li><li>observationInfo结构 (箭头所指是我们等下需要用到的地方)</li></ol><ul><li>第二步 实现方案思路</li></ul><ol><li><p>通过私有属性直接拿到当前对象所监听的keyPath</p></li><li><p>判断keyPath有或者无来实现防止多次重复添加和删除KVO监听。</p></li><li><p>通过Dump Foundation.framework 的头文件，和直接xcode查看observationInfo的结构，发现有一个数组用来存储NSKeyValueObservance对象，经过测试和调试，发现这个数组存储的需要监听的对象中，监听了几个属性，如果监听两个，数组中就是2个对象。比如这是监听两个属性状态下的数组</p></li><li><p>NSKeyValueObservance属性简单说明</p><blockquote><p>_observer属性：里面放的是监听属性的通知这，也就是当属性改变的时候让哪个对象执行observeValueForKeyPath的对象。</p><p>_property 里面的NSKeyValueProperty NSKeyValueProperty存储的有keyPath,其他属性我们用不到，暂时就不说了。</p></blockquote></li><li><p>拿出keyPath</p></li></ol><p>这时候思路就有了，首先拿出_observances数组，然后遍历拿出里面_property对象里面的NSKeyValueProperty下的一个keyPath，然后进行判断需要删除或添加的keyPath是否一致，然后分别进行处理就行了。</p><p><strong>补充：NSKeyValueProperty我当时测试直接kvc取出来的时候发现取不出来，报错，后台直接取keyPath就可以，然后就直接取keyPath了，有知道原因的可以给我说下。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">+ (void)switchMethod</span><br><span class="line">&#123;</span><br><span class="line">    SEL removeSel = @selector(removeObserver:forKeyPath:);</span><br><span class="line">    SEL myRemoveSel = @selector(removeDasen:forKeyPath:);</span><br><span class="line">    Method systemRemoveMethod = class_getClassMethod([self class],removeSel);</span><br><span class="line">    Method DasenRemoveMethod = class_getClassMethod([self class], myRemoveSel);</span><br><span class="line">    method_exchangeImplementations(systemRemoveMethod, DasenRemoveMethod);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SEL addSel = @selector(addObserver:forKeyPath:options:context:);</span><br><span class="line">    SEL myaddSel = @selector(addDasen:forKeyPath:options:context:);</span><br><span class="line">    Method systemAddMethod = class_getClassMethod([self class],addSel);</span><br><span class="line">    Method DasenAddMethod = class_getClassMethod([self class], myaddSel);</span><br><span class="line">    method_exchangeImplementations(systemAddMethod, DasenAddMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 第二种方案，利用私有属性</span><br><span class="line">// 交换后的方法</span><br><span class="line">- (void)removeDasen:(NSObject *)observer forKeyPath:(NSString *)keyPath&#123;</span><br><span class="line"></span><br><span class="line">    // 如果有该key值那么进行删除</span><br><span class="line">    if ([self observerKeyPath:keyPath]) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            //如果没有写@try @catch 的话，在 dealloc 中，那个被监听的对象（appdelegate）必须要全局变量</span><br><span class="line">            [self removeDasen:observer forKeyPath:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">        @catch (NSException *exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addDasen:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123;</span><br><span class="line"></span><br><span class="line">    // 如果没有注册，那么才进行注册 第三步 存储之前的检索处理</span><br><span class="line">    if (![self observerKeyPath:keyPath]) &#123;</span><br><span class="line">        [self addDasen:observer forKeyPath:keyPath options:options context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 进行检索获取Key</span><br><span class="line">- (BOOL)observerKeyPath:(NSString *)key &#123;</span><br><span class="line"></span><br><span class="line">    id info = self.observationInfo;</span><br><span class="line"></span><br><span class="line">    //_observer属性：里面放的是监听属性的通知，也就是当属性改变的时候让哪个对象执行observeValueForKeyPath的对象。</span><br><span class="line">    NSArray *array = [info valueForKey:@&quot;_observances&quot;];</span><br><span class="line"></span><br><span class="line">    for (id objc in array) &#123;</span><br><span class="line">        //_property 里面的NSKeyValueProperty存储的有keyPath,其他属性我们用不到，暂时就不说了。</span><br><span class="line">        id Properties = [objc valueForKeyPath:@&quot;_property&quot;];</span><br><span class="line">        NSString *keyPath = [Properties valueForKeyPath:@&quot;_keyPath&quot;];</span><br><span class="line"></span><br><span class="line">        if ([key isEqualToString:keyPath]) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://github.com/yuanliangYL/YLCrashhandler">Demo地址:https://github.com/yuanliangYL/YLCrashhandler</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> iOS Crash Handle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS音视频开发（一）重识图片、声音与视频</title>
      <link href="/2021/08/04/iOS%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E4%B8%80/"/>
      <url>/2021/08/04/iOS%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h4 id="一-图片"><a href="#一-图片" class="headerlink" title="一. 图片"></a>一. 图片</h4><blockquote><ul><li><p>每张图片都有N个像素组成（N&gt;=1）</p></li><li><p>如果一张图片的分辨率是W x H, 那么：</p></li></ul><ol><li><p>每一行都有W个像素，共有H行，总计W*H个像素</p></li><li><p>宽度是W像素，高度是H像素</p></li></ol><ul><li>每一个像素都有其独立的颜色！！！</li></ul></blockquote><hr><h4 id="二、RGB颜色模型"><a href="#二、RGB颜色模型" class="headerlink" title="二、RGB颜色模型"></a>二、RGB颜色模型</h4><blockquote><ul><li>RGB Color Model: RGB颜色模型（三原色 光模式）</li></ul><ol><li>R+G=Y</li><li>R+B=Magenta洋红色</li><li>G+B=Cyan青色[saɪæn]</li><li>R+G+B=W</li></ol></blockquote><p>思考：每一个像素的颜色信息是符合存储的？</p><blockquote><ul><li><p>位深度Bit Depth == 色彩深度（色深）Color Depth</p></li><li><p><strong>如果一张图片的位深度位n，那么它的每一个像素都会使用n个二进制位来存储颜色信息！！</strong></p></li><li><p>常见位深度是：24 ,表示每一个像素都会使用24个二进制位来存储颜色信息；</p></li><li><p>因为每一个像素的颜色都是用R、G、B这3个<strong>颜色通道</strong>合成的；</p></li><li><p>每个颜色通道都用8bit（位）表示其“含量”值（范围0000 0000 — 1111 1111，即0-255或00-FF）：</p><table><thead><tr><th align="center">颜色</th><th align="center">rgb表示</th><th align="center">十六进制表示</th></tr></thead><tbody><tr><td align="center">红色</td><td align="center">rgb(255,0,0)</td><td align="center">#ff0000</td></tr><tr><td align="center">绿色</td><td align="center">rgb(0,255,0)</td><td align="center">#00ff00</td></tr><tr><td align="center">蓝色</td><td align="center">rgb(0,0,255)</td><td align="center">#0000ff</td></tr><tr><td align="center">黄色</td><td align="center">rgb(255,255,0)</td><td align="center">#ffff00</td></tr><tr><td align="center">洋红色</td><td align="center">rgb(255,0,255)</td><td align="center">#ff00ff</td></tr><tr><td align="center">青色</td><td align="center">rgb(0,255,255)</td><td align="center">#00ffff</td></tr><tr><td align="center">白色</td><td align="center">rgb(255,255,255)</td><td align="center">#ffffff</td></tr><tr><td align="center">黑色</td><td align="center">rgb(0,0,0)</td><td align="center">#000000</td></tr></tbody></table></li></ul></blockquote><hr><h4 id="三、图片格式："><a href="#三、图片格式：" class="headerlink" title="三、图片格式："></a>三、图片格式：</h4><blockquote><p>位图与矢量图的区别：</p><p>分辨率：位图的质量与分辨率有关。而矢量图的质量与分辨率没有任何关系。</p><p>绘图工具：矢量图一般是用Adobe公司的Illustrator，而位图则使用的是Photoshop和Windows系统所自带的画图。</p><p>性质：位图是由像素所组成的点阵图像，矢量图是使用直线和曲线来描述图形。</p></blockquote><ol><li><p>png、jpg、gif三种格式称为位图</p></li><li><p>svg：矢量图</p><blockquote><ul><li><p>图片大小的计算：</p></li><li><p>理论值：</p><p>24位深度下，每个像素占3个字节，按kb计算: 像素<em>字节 =  (50 * 60 )</em> ( 24 / 8 ) = 9000b = 8.79kb(9000b/1024)</p></li></ul></blockquote></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> iOS音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    
  
  
</search>
